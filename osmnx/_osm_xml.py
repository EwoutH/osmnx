"""Read/write OSM XML files."""

from __future__ import annotations

import bz2
import logging as lg
from pathlib import Path
from typing import TYPE_CHECKING
from typing import Any
from typing import TextIO
from warnings import warn
from xml.etree.ElementTree import Element
from xml.etree.ElementTree import ElementTree
from xml.etree.ElementTree import SubElement
from xml.etree.ElementTree import parse as etree_parse
from xml.sax import parse as sax_parse
from xml.sax.handler import ContentHandler

import networkx as nx
import pandas as pd

from . import settings
from . import utils
from . import utils_graph
from ._errors import GraphSimplificationError
from ._version import __version__

if TYPE_CHECKING:
    from xml.sax.xmlreader import AttributesImpl

    import geopandas as gpd


class _OSMContentHandler(ContentHandler):
    """
    SAX content handler for OSM XML.

    Builds an Overpass-like response JSON object in self.object. For format
    notes, see https://wiki.openstreetmap.org/wiki/OSM_XML and
    https://overpass-api.de
    """

    def __init__(self) -> None:  # noqa: ANN101
        self._element: dict[str, Any] | None = None
        self.object: dict[str, Any] = {"elements": []}

    def startElement(self, name: str, attrs: AttributesImpl) -> None:  # noqa: ANN101,N802
        float_attrs = {"lat", "lon"}
        int_attrs = {"id", "uid", "version", "changeset"}
        meta_attrs = {"version", "generator"}

        if name == "osm":
            self.object.update({k: v for k, v in attrs.items() if k in meta_attrs})

        elif name in {"node", "way"}:
            self._element = dict(type=name, tags={}, nodes=[], **attrs)
            self._element.update({k: float(v) for k, v in attrs.items() if k in float_attrs})
            self._element.update({k: int(v) for k, v in attrs.items() if k in int_attrs})

        elif name == "relation":
            self._element = dict(type=name, tags={}, members=[], **attrs)
            self._element.update({k: int(v) for k, v in attrs.items() if k in int_attrs})

        elif name == "tag":
            self._element["tags"].update({attrs["k"]: attrs["v"]})  # type: ignore[index]

        elif name == "nd":
            self._element["nodes"].append(int(attrs["ref"]))  # type: ignore[index]

        elif name == "member":
            self._element["members"].append(  # type: ignore[index]
                {k: (int(v) if k == "ref" else v) for k, v in attrs.items()},
            )

    def endElement(self, name: str) -> None:  # noqa: ANN101,N802
        if name in {"node", "way", "relation"}:
            self.object["elements"].append(self._element)


def _overpass_json_from_xml(filepath: str | Path, encoding: str) -> dict[str, Any]:
    """
    Read OSM XML data from file and return Overpass-like JSON.

    Parameters
    ----------
    filepath
        Path to file containing OSM XML data.
    encoding
        The XML file's character encoding.

    Returns
    -------
    response_json
        A parsed JSON response from the Overpass API.
    """

    # open the XML file, handling bz2 or regular XML
    def _opener(filepath: Path, encoding: str) -> TextIO:
        if filepath.suffix == ".bz2":
            return bz2.open(filepath, mode="rt", encoding=encoding)

        # otherwise just open it if it's not bz2
        return filepath.open(encoding=encoding)

    # warn if this XML file was generated by OSMnx itself
    with _opener(Path(filepath), encoding) as f:
        root_attrs = etree_parse(f).getroot().attrib  # noqa: S314
        if "generator" in root_attrs and "OSMnx" in root_attrs["generator"]:
            msg = (
                "The XML file you are loading appears to have been generated "
                "by OSMnx: this use case is not supported and may not behave "
                "as expected. To save/load graphs to/from disk for later use "
                "in OSMnx, use the `io.save_graphml` and `io.load_graphml` "
                "functions instead. Refer to the documentation for details."
            )
            warn(msg, category=UserWarning, stacklevel=2)

    # parse the XML to Overpass-like JSON
    with _opener(Path(filepath), encoding) as f:
        handler = _OSMContentHandler()
        sax_parse(f, handler)  # noqa: S317
        return handler.object


def _save_graph_xml(
    G: nx.MultiDiGraph,
    filepath: str | Path | None,
    oneway: bool,  # noqa: FBT001
    merge_edges: bool,  # noqa: FBT001
    way_tags_agg: dict[str, Any] | None,
) -> None:
    """
    Save graph to disk as an OSM XML file.

    See format notes at: https://wiki.openstreetmap.org/wiki/OSM_XML

    Current OSM editing API version: https://wiki.openstreetmap.org/wiki/API

    Parameters
    ----------
    G
        The graph to save.
    filepath
        Path to the OSM XML file including extension. If None, use default
        `settings.data_folder/graph.osm`.
    oneway
        The default "oneway" value used to fill this tag where missing.
    merge_edges
        If True, merge graph edges such that each OSM way has one entry and
        one entry only in the OSM XML. Otherwise, every OSM way will have a
        separate entry for each node pair it contains.
    way_tags_agg
        Useful only if `merge_edges` is True, this argument allows the user to
        specify edge attributes to aggregate such that the merged OSM way
        entry tags accurately represent the sum total of their component edge
        attributes. For example, if the user wants the OSM way to have a
        "length" attribute, the user must specify
        `way_tags_agg={"length": "sum"}` in order to tell this function to
        aggregate the lengths of the individual component edges. Otherwise,
        the length attribute will simply reflect the length of the first edge
        associated with the way.

    Returns
    -------
    None
    """
    if not settings.all_oneway:
        msg = "Make sure graph was created with `ox.settings.all_oneway=True` to save as OSM XML."
        warn(msg, category=UserWarning, stacklevel=2)

    if merge_edges and G.graph.get("simplified", False):
        msg = "Graph must be unsimplified to save as OSM XML."
        raise GraphSimplificationError(msg)

    # default filepath if None was provided
    filepath = Path(settings.data_folder) / "graph.osm" if filepath is None else Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)

    # convert graph to node/edge GeoDataFrames for saving
    gdf_nodes, gdf_edges = utils_graph.graph_to_gdfs(
        G,
        node_geometry=False,
        fill_edge_geometry=False,
    )

    # add default values (if missing) for required attrs to meet OSM XML spec
    attr_defaults = {
        "uid": "1",
        "user": "OSMnx",
        "version": "1",
        "changeset": "1",
        "timestamp": utils.ts(template="{:%Y-%m-%dT%H:%M:%SZ}"),
    }
    for gdf in (gdf_nodes, gdf_edges):
        for col, value in attr_defaults.items():
            if col not in gdf.columns:
                gdf[col] = value

    # transform nodes gdf to meet OSM XML spec
    # 1) reset index (osmid) then rename osmid, x, and y columns
    # 2) round lat/lon columns to 6 decimals (approx 5 to 10 cm resolution)
    # 3) retain only node cols corresponding to configured node attrs and tags
    gdf_nodes = gdf_nodes.reset_index().rename(columns={"osmid": "id", "x": "lon", "y": "lat"})
    gdf_nodes[["lon", "lat"]] = gdf_nodes[["lon", "lat"]].round(6)
    node_cols = list(set(settings.osm_xml_node_attrs) | set(settings.osm_xml_node_tags))
    gdf_nodes = gdf_nodes[node_cols]

    # transform edges gdf to meet OSM XML spec
    # 1) fill and convert oneway bools to strings
    # 2) rename osmid column (but keep (u, v, k) index for processing)
    # 3) retain only edge cols corresponding to configured edge attrs and tags
    if "oneway" in gdf_edges.columns:
        gdf_edges["oneway"] = gdf_edges["oneway"].fillna(oneway).replace({True: "yes", False: "no"})
    edge_cols = list(set(settings.osm_xml_way_attrs) | set(settings.osm_xml_way_tags))
    gdf_edges = gdf_edges.rename(columns={"osmid": "id"})[edge_cols]

    # create parent XML element then add nodes and ways as sub elements
    element = Element("osm", attrib={"version": "0.6", "generator": f"OSMnx {__version__}"})
    element = _add_nodes_xml(element, gdf_nodes)
    element = _add_ways_xml(element, gdf_edges, merge_edges, way_tags_agg)

    # write to disk
    ElementTree(element).write(filepath, encoding="utf-8", xml_declaration=True)
    msg = f"Saved graph as OSM XML file at {str(filepath)!r}"
    utils.log(msg, level=lg.INFO)


def _add_nodes_xml(
    parent: Element,
    gdf_nodes: gpd.GeoDataFrame,
) -> Element:
    """
    Add graph nodes as sub elements of XML parent element.

    Parameters
    ----------
    parent
        The XML parent element.
    gdf_nodes
        A GeoDataFrame of graph nodes.
    node_attrs
        OSM node attributes to include for each node.
    node_tags
        OSM node tags to add as sub elements of each node.

    Returns
    -------
    parent
        Updated XML parent element with node sub elements.
    """
    node_attrs = set(settings.osm_xml_node_attrs)
    node_tags = set(settings.osm_xml_node_tags)

    # convert gdf rows to generator of col:val dicts with null vals removed
    rows = gdf_nodes.where(gdf_nodes.isna(), gdf_nodes.astype(str)).to_dict(orient="records")
    nodes = ({k: v for k, v in d.items() if pd.notna(v)} for d in rows)

    # add each node attr dict as a SubElement of parent
    for node in nodes:
        node_attr = {k: node[k] for k in node.keys() & node_attrs}
        se = SubElement(parent, "node", attrib=node_attr)

        # add each tag key:value dict as a SubElement of the node SubElement
        for k in node.keys() & node_tags:
            node_tag = {"k": k, "v": node[k]}
            _ = SubElement(se, "tag", attrib=node_tag)

    return parent


def _add_ways_xml(
    parent: Element,
    gdf_edges: gpd.GeoDataFrame,
    merge_edges: bool,  # noqa: FBT001
    way_tags_agg: dict[str, Any] | None,
) -> Element:
    """
    Add graph edges (grouped as ways) as sub elements of XML parent element.

    Parameters
    ----------
    parent
        The XML parent element.
    gdf_edges
        A GeoDataFrame of graph edges with OSM way "id" column for grouping
        edges into ways.
    merge_edges
        If True, merge graph edges such that each OSM way has one entry and
        one entry only in the OSM XML. Otherwise, every OSM way will have a
        separate entry for each node pair it contains.
    way_tags_agg
        Useful only if `merge_edges` is True, this argument allows the user to
        specify edge attributes to aggregate such that the merged OSM way
        entry tags accurately represent the sum total of their component edge
        attributes. For example, if the user wants the OSM way to have a
        "length" attribute, the user must specify
        `way_tags_agg={"length": "sum"}` in order to tell this function to
        aggregate the lengths of the individual component edges. Otherwise,
        the length attribute will simply reflect the length of the first edge
        associated with the way.

    Returns
    -------
    parent
        Updated XML parent element with edge sub elements.
    """
    if merge_edges:
        for osmid, way in gdf_edges.groupby("id"):
            # STEP 1: add the way and its attrs as a "way" sub element of the
            # parent element
            attrs = way[settings.osm_xml_way_attrs].iloc[0].astype(str).to_dict()
            way_element = SubElement(parent, "way", attrib=attrs)

            # STEP 2: add the way's edges' node IDs as "nd" sub elements of
            # the "way" sub element. if way contains more than 1 edge, sort
            # the nodes topologically, otherwise no need to sort.
            if len(way) > 1:
                nodes = _sort_nodes(nx.MultiDiGraph(way.index.to_list()), osmid)
            else:
                nodes = way.index[0][:2]
            for node in nodes:
                SubElement(way_element, "nd", attrib={"ref": str(node)})

            # STEP 3: add way's edges' tags as "tag" sub elements of the "way"
            # sub element. if an agg function was provided for a tag, apply it
            # to the values of the edges in the way. if no agg function was
            # provided for a tag, just use the value from first edge in way.
            for tag in settings.osm_xml_way_tags:
                if way_tags_agg is not None and tag in way_tags_agg:
                    value = way[tag].agg(way_tags_agg[tag])
                else:
                    value = way[tag].iloc[0]
                if pd.notna(value):
                    SubElement(way_element, "tag", attrib={"k": tag, "v": str(value)})

    # otherwise, merge_edges=False, so each OSM way will have a separate
    # element added for each node pair it contains
    else:
        set_way_attrs = set(settings.osm_xml_way_attrs)
        set_way_tags = set(settings.osm_xml_way_tags)
        for (u, v, k), data in gdf_edges.to_dict(orient="index").items():
            # STEP 1: add the way and its attrs
            attrs = {k: str(v) for k, v in data.items() if k in set_way_attrs}
            way_element = SubElement(parent, "way", attrib=attrs)

            # STEP 2: add the way's constituent node IDs
            SubElement(way_element, "nd", attrib={"ref": str(u)})
            SubElement(way_element, "nd", attrib={"ref": str(v)})

            # STEP 3: add the way's edges' tags
            tags = {
                k: v
                for k, v in data.items()
                if k in set_way_tags and (isinstance(v, list) or pd.notna(v))
            }
            for tag, value in tags.items():
                SubElement(way_element, "tag", attrib={"k": tag, "v": str(value)})

    return parent


def _sort_nodes(G: nx.MultiDiGraph, osmid: int) -> list[int]:
    """
    Topologically sort the nodes of an OSM way.

    Parameters
    ----------
    idx
        The graph representing the OSM way.
    osmid
        The OSM way ID (only used for logging).

    Returns
    -------
    ordered_nodes
        The way's node IDs in topologically sorted order.
    """
    try:
        ordered_nodes = list(nx.topological_sort(G))

    except nx.NetworkXUnfeasible:
        # if it couldn't topologically sort the nodes, the way probably
        # contains a cycle. try removing an edge to break the cycle. first,
        # look for multiple edges emanating from the same source node
        insert_before = True
        edges = [
            edge
            for source in [node for node, degree in G.out_degree() if degree > 1]
            for edge in G.out_edges(source, keys=True)
        ]

        # if none found, then look for multiple edges pointing at the same
        # target node instead
        if len(edges) == 0:
            insert_before = False
            edges = [
                edge
                for target in [node for node, degree in G.in_degree() if degree > 1]
                for edge in G.in_edges(target, keys=True)
            ]

            # if still none, then take the first edge of the way: the entire
            # way could just be a cycle in which each node appears once
            if len(edges) == 0:
                edges = [next(iter(G.edges))]

        # remove one edge at a time and see if the graph remains connected
        # and if we are able to topologically sort its nodes
        for edge in edges:
            G_ = G.copy()
            G_.remove_edge(*edge)
            if nx.is_weakly_connected(G_):
                break

        try:
            ordered_nodes = list(nx.topological_sort(G_))

            # re-insert (before or after its neighbor as needed) the duplicate
            # source or target node from the edge we removed
            dupe_node = edge[0] if insert_before else edge[1]
            neighbor = edge[1] if insert_before else edge[0]
            position = ordered_nodes.index(neighbor)
            position = position if insert_before else position + 1
            ordered_nodes.insert(position, dupe_node)

        except nx.NetworkXUnfeasible:
            # if it failed again, this way probably contains multiple cycles,
            # so remove a cycle then try to sort the nodes again, recursively.
            # note this is destructive and will be missing in the saved data.
            G_ = G.copy()
            G_.remove_edges_from(nx.find_cycle(G_))
            G_ = utils_graph.remove_isolated_nodes(G_)
            ordered_nodes = _sort_nodes(G_, osmid)
            msg = f"Had to remove a cycle from way {str(osmid)!r} for topological sort"
            utils.log(msg, level=lg.WARNING)

    return ordered_nodes
